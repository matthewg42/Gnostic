Gnostic
-------

Gosh, Network Operation Seems Terrifically Interesting. Champion!
Gates' Nearly Omnipotent Software That Is Cromulent.
Get New Operating System. The Is Crap" (choose your target platform)
Gnostic's not overly stupid, technically it's complicated
Graphic Notifying Omni-Platform Software Tool Inspecting Clusters
Gnostic Notifies On Servers Taking Inconvenient Craps
Great, No One Saw That It Crashed
Gnostiq: Graphing, Notification, Omni-Platform Surveillance Tool In Qt4

What it is
----------

It's a remote process montoring visualization tool.

Gnostic connects to remote servers, executes a command there, and plots
pretty graphs from the output of those remote programs.

These programs are called Monitors, and are simply programs which
spit out data in a format which Gnostic understands. They can be
implemented any which way you like, but are typically something like
a Perl script.  Their output should adhere to the Gnosic Data Protocol
(see below).  The short version is: three delimited fields per line:
a timestamp, a label and a numeric value.

Gnostic makes time / value charts from this.  The definition of a
Monitor also includes stuff like:
- path to program to execute on remote host
- arguments to remote program
- value (Y) axis: fixed scale or auto scale?
- how much history should there be?
- refresh rate
- scrolling or wrapping?

Anyway, Monitor definitions are separate from Transports, which are the
way in which the connection to the remote host is done.  That method -
the "Transport", contains information about the conenction...
authentication credentials, actual mechanism and so on.

So the user sets up one or more Transports, and one or more Monitors
and then calls a Monitor with a Transport - a so-called
RemoteTransport.


Dependencies
------------

for OpenSshTransport: ssh-askpass or compatibile, openssh
for PlinkTransport: plink

Windows remote exec.  Hmm.
-------------------------

Well here's a thing, remotely executing a command on a windows server and
getting a bunch of text back is a pain in the ass.  Looks like the only
native method is rexec, presumably from their POSIX layer, which makes me
shudder.

So the options are:  install ssh servers on remote hosts, or maybe a light
weight custom process launcher, and make a transport class for that...

The problem is authentication.  Don't want to send passwords in the clear
but would like to use windows authentication if possible... which means
having a public key system to exchange a session key for a stream cipher,
which is essentially re-implementing a part of the SSH protocol.  Ho hum.

Need to have a think on that.


Thinking out loud
-----------------

Transport::start(exe, args)
Transport::spewLine() --> GnosticParser::takeLine()
			  {
			      // process headers & set up internal state
			      // wait for end of headers and then...
			      emit(spewLine(raw line));
			      filter & split
			      emit(spewDataItem(timestamp, value, label));
			  }

Now we might have a simple tailer object hooked up like this:

GnosticParser::spewLine() --> TailerDataDisplay::takeLine()
			 {
			     // colorize based on REs
			     // filter
			     // display
			 }

Or even simpler:

GnosticParser::spewLine() --> CounterDataDisplay::takeLine()
			 {
			     // increment counter widget
			 }


But the real goal is this:
GnosticParser::spewDataItem() --> Grapher::plotDataItem()
			     {
				 // do that graphing goodness.
			     }


Monitors
--------

For monitors to be configured in the same way as the Transports (one window,
config dependent on type which provides a function to get a widget to configure
a Monitor...)... we need to derive them all from one abstract type, and have
generalised methods for:
- getting config widget
- loading (static)
- saving
- updating
- connecting to a GnosticParser object

Implementation strategy:
1. Make a single CounterDataDisplay class
   - hook it up to a transport & GnosticParser
   - hook GnosticParser up to a real transport
   - watch it work

2. Abstract out base class
3. Implement TailerDataDisplay class as sibling of CounterDataDisplay
4. make CounterDataDisplayConfigWidget & TailerDataDisplayConfigWidget
5. Hone the base class some
6. Implement GraphDataDisplay as sibling of TailerDataDisplay & co.
   - also GraphDataDisplayConfigWidget

After that all we have to do is make a nice GUI for pairing
Transports and DataDisplays, and a way to launch these pairs and
we're more or less done!


Remote monitor protocol
-----------------------

GNOSTIC-DATA-PROTOCOL-VERSION=1.0
HOST=the.fq.hostname
INVOCATION-PATH=/whatever/the/program/was
INVOCATION-ARGS="list" "of" "quoted arguments"
MONITOR-NAME=Some monitor
UPDATE-DELAY=1.0
DELIMITER=:
END-HEADER
timstamp:value:label
timstamp:value:label
timstamp:value:label
GNOSTIC-WARNING=System going down in 3 mins
timstamp:value:label
timstamp:value:label
timstamp:value:label
GNOSTIC-ERROR=Monitor sent TERM signal, BYE

timestamps are in number of milli-seconds since epoch.


TODO for 1st release
--------------------

win32 build:
- package plink

---

chase down TODO tags in code

---

make debug level appropriate

---

Remove setting of descriptions, add automatic deriving from other data items

---

---

color dialog

Second release goals
--------------------

- Make a "Configurable Item" class & derive stuff from it
- Have a "Configurable Item Config Widget" parner class
- Automatic discovery of "used child items"
- export / import settings

